h2 Här finns det dokumentation!

h3 Vecka 12
p Denna vecka valde jag att påbörja arbetet med grundprojektet på E-nivå eftersom att det ordinarie projektet har kännts mycket tufft. Jag började med att skapa ett formulär för att byta användarnamn, men eftersom att användarnamnet är hårdkodat i ruby fungerar det inte för tillfället. 
p Efter detta påbörjade jag utveckling av ett formulär för att skapa nya notes. Eftersom att jag ville att varje note utöver själva anteckningen också skulle ha en titel, samt information om vilken användare som skrivit den skapade jag ett create-formulär med POST-metod som hade totalt fyra inputs; Två textinputs, en för rubrik och en för innehållet; En hidden input, som automatiskt inputtar användarnamnet genom att ge "#{session["user"]}" som value; Sist en submitknapp för att skapa en ny note. Lite svårt hade jag för att lista ut hur jag sedan skulle ordna all denna information på /notes, där alla notes visas. Från början försökte jag att lägga rubrik, innehåll och author i var sin array, vilka jag sedan iterativt skrev ut på sidan. Detta gick såklart inte, eftersom att det gjorde att jag först skrev ut alla rubriker, sedan alla innehåll och sist alla authors, istället för att varje note fick en rubrik, content och author var. Detta hann jag inte lösa under lektionen.
h3 Vecka 13-14
p Påsklov - Inget arbete 
h3 Vecka 15
p För att lösa problemet med att användarnamn skrivs över direkt efter att de redigerats på grund av att det är hårdkodat i ruby valde jag att justera rubykoden. Ursprungligen bestämdes användarnamnet genom session["user"] = "John Smith", vilket gjordes i en before-sats. För att göra det möjligt att ändra detta användarnamn skrev jag istället session["user"] = username, där variabeln username utanför before-satsen defineras som "John Smith". Sedan såg jag till att variabeln username blev lika med params["nytt_namn"], vilket är parametern som formuläret för att ändra användarnamn ger. På så sätt kunde man nu ändra användarnamn. Såklart sparas inte dessa förändringar när servern stängs ner eftersom att de bara lagras i sessions, men så länge servern är på gäller förändringen.
p Nästa steg var att lösa det andra problemet jag stötte på vecka 12, alltså att korrekt visa informationen från notes-formuläret. För att få korrekt formatering av notes på /notes-sidan insåg jag att jag skulle behöva ha all information från create-formuläret i en och samma array, och för att göra det så enkelt som möjligt för mig ville jag att denna array skulle vara session["notes"] = []. För att åstadkomma detta skapade jag en array som jag kallade post, och definerade på följande vis post = [params["ny_title"], params["ny_content"], params["author"]]. Alltså innehåller arrayen post rubrik, innehåll och author för en note. Denna array pushar jag sedan in i arrayen session["notes"], som jag nämnde tidigare. Varje element i arrayen session["notes"] är alltså en egen array som innehåller title, content och author för en note. För att sedan skriva ut varje note på /notes skapade jag en if-sats där jag, förutsatt att session["notes"] innehåller data, med funktionen .each_with_index och argumenten notes och i (- session["notes"].each_with_index do |notes, i|), skriver jag ut varje element på var sin rad genom att specificera vilket index som ska skrivas ut. 
p För att kunna ta bort notes skapade jag två formulär; Ett delete-formulär, som bara tar bort en specifik note och ett destroy-formulär, som tar bort samtliga notes. Delete-formuläret fungerar genom att varje note tilldelas ett id i formuläret, vilket gör att man genom .delete_at-funktionen kan ta bort specifika notes. Detta visas efter varje note genom .each_with_index. Till skillnad från delete-formuläret gör destroy-formuläret att session["notes"] = nil. Arrayen som innehåller alla notes tas alltså bort. Detta formulär visas endast en gång, längst ner på sidan.  
p Några speciellt stora hinder visade sig inte detta pass. De mindre frågetecken som uppstod löste jag med hjälp av duckduckgo och klasskamrater. 
h3 Vecka 16
p Denna veckas arbete började i utveckling av login-funktionalitet. Till att börja med skapade jag en ny slim-fil, login.slim. I denna fil skapade jag ett login-formulär med post-metod och tre inputs: En textinput för username, en passwordinput och en submitknapp. I ruby skapade jag en get-route som visar login-sidan, och en post-route, som förutsatt att användarnamn och lösenord är korrekt, låter användaren logga in och redirectar till /users, som i sin tur visar /users/index, vilket är den ursprungliga index-sidan. Om lösenord och/eller användarnamn är inkorrekt redirectas användaren istället till en errorsida där ett felmeddelande visas. Om användaren inte är inloggad kan den inte skapa nya notes eller ta bort redan existerade notes, eller ändra användarinformation, men skulle kunna se existerande genom att skriva in tillhörande url i adressfältet. Däremot finns ingen länk till /notes för icke-inloggade användare. Icke inloggade användare hindras från att få tillgång till sidor de ej har behörighet att se med hjälp av en if-sats som i routen ser till att session['logged_in'] = true. 
p Som "valfri funktionalitet valde jag att göra det möjligt för inloggade användare att CRUDda ytterliggare användarinformation: Ålder och bio. Detta görs på samma sida som man byter användarnamn, alltså /users/edit. Denna information visas sedan på /users/index under rubriken "Användarinformation". Användarinformationen placeras i en array med ett index för ålder respektive bio och kan enkelt uppdateras genom att specificera på vilket index i arrayen informationen ska uppdateras. 
p Det sista jag gjorde var att skapa en slimfil för dokumentation. I denna skrev jag in all den dokumentation jag fört på papper under arbetet med grundprojektet. En länk till dokumentationssidan lades i sidans header och visas oavsett login-status.
p Ett problem jag stötte på under arbetet denna vecka var att man till en början som icke inloggad användare kunde komma åt funktioner man inte borde, men lyckades lösa detta genom att checka login-status med en if-sats på de ställen det behövdes.
h3 Vecka 18-20
p Dessa veckor gick till att konvertera grundprojektet från att endast lagra data i sessions till att istället använda databas för mer permanent lagring av information. 
p Först skapades en databas med två tabeller, users och notes. users innehåller all information om användare; användarnamn, id, lösenord (krypterat såklart), ålder och bio. I notes finns all data relaterad till notes, alltså titel, content, id och användar-id. 
p För att göra det möjligt att logga in krävdes nu att det fanns konton att logga in på, därför skapades ett formulär för att registrera konton, så jag skapade users/new.slim, som innehåller ett register-formulär som med post-metod låter användare skapa konton på hemsidan. För att undvika problem infördes viss felhantering, som gör det omöjligt att skapa konton utan att inputta användarnamn eller lösenord. Create-formuläret har dessutom två password-fält, som måste matcha för att kunna skapa ett konto. Om användaren gör fel vid registrering redirectas denne till lämplig error-sida, där information om vad som gick fel till visas. 
p Vid registrering krypteras det inputtade lösenordet med BCrypt, och lagras krypterat i databasen under users/pwdigest. För att göra krypteringen extra säker saltas lösenordet. 
p Post-routen till loginformuläret uppdaterades till att nu checka användarnamn och lösenord mot databasen. Lösenordet saltas och krypteras för att sedan jämföras mot de lagrade, krypterade lösenorden vid users/pwdigest i databasen.
p För att slippa repetera kod för att hämta databasen och skriva samma SQL-query flera gånger används drykod. Exempelvis gör funktionen checkusername(id) det smidigare att hitta ett användarnamn kopplat till ett användar-id. 
p När man skapar nya notes insertas title, content och user_id in på en ny rad i notes-tabellen i databasen. Om någon försöker skapa en ny note utan att skriva något i textfälten redirectas de till en errorsida. När en användare trycker på delete-knappen på en note används SQL DELETE för att ta bort all information på raden i notes-tabellen med tillhörande note-id. Om en användare trycker på destroy-knappen används DELETE istället för att ta bort alla notes kopplade till användarens user_id. 
p När användare vill ändra sin användarinformation används SQL UPDATE för att ange nya värden på username, age eller bio i users-tabellen i databasen. Om användaren vill ta bort information om ålder eller bio används SQL update för att sätta värdet på tillhörande node i users-tabellen till nil. 
